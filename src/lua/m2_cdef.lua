-- Autogenerated file - don't touch
local ffi = require 'ffi'
ffi.cdef [[
       
       
       
       
typedef uint8_t bm8 __attribute__((aligned(16)));
bm8 *bm_alloc(size_t n);
void bm_free(bm8 *bm);
void bm_set64(bm8 *bm, size_t n, uint64_t c);
void bm_zero(bm8 *bm, size_t n);
void bm_copy(bm8 *restrict a, const bm8 *restrict b, size_t n);
void bm_and64(bm8 *bm, size_t n, uint64_t mask);
void bm_or64(bm8 *bm, size_t n, uint64_t mask);
void bm_xor64(bm8 *bm, size_t n, uint64_t mask);
void bm_and(bm8 *restrict a, const bm8 *restrict b, size_t n);
void bm_or(bm8 *restrict a, const bm8 *restrict b, size_t n);
void bm_xor(bm8 *restrict a, const bm8 *restrict b, size_t n);
void bm_not(bm8 *bm, size_t n);
void bs_zero(bm8 *bs, size_t n);
unsigned bs_get(bm8 *bs, size_t idx);
void bs_set(bm8 *bs, size_t idx);
void bs_clear(bm8 *bs, size_t idx);
uint64_t bmask8(uint8_t mask8);
uint64_t bmask16(uint16_t mask16);
uint64_t bmask32(uint32_t mask32);
typedef uint64_t gridpos;
typedef uint32_t gridcoord;
struct grid {
 size_t order;
 size_t stride;
 void *data;
};
struct bitgrid {
 size_t order;
 bm8 *bs;
};
size_t grid_data_size(size_t order, size_t stride);
void grid_init(struct grid *g, size_t order, size_t stride, void *data);
void *grid_data(struct grid *g, gridpos z);
gridpos grid_max(size_t order);
gridpos grid_pos(gridcoord x, gridcoord y);
gridpos grid_zoom_up(gridpos z, size_t from, size_t to);
gridpos grid_zoom_down(gridpos z, size_t from, size_t to);
gridpos grid_translate_mask(size_t from, size_t to);
typedef enum type {
 T_F64 = (((0) << 2) | ((!!((8)&0xa)) | ((!!((8)&0xc))<<1))),
 T_F32 = (((0) << 2) | ((!!((4)&0xa)) | ((!!((4)&0xc))<<1))),
 T_B64 = (((1) << 2) | ((!!((8)&0xa)) | ((!!((8)&0xc))<<1))),
 T_B32 = (((1) << 2) | ((!!((4)&0xa)) | ((!!((4)&0xc))<<1))),
 T_B16 = (((1) << 2) | ((!!((2)&0xa)) | ((!!((2)&0xc))<<1))),
 T_B8 = (((1) << 2) | ((!!((1)&0xa)) | ((!!((1)&0xc))<<1))),
 T_BOOL64 = (((2) << 2) | ((!!((8)&0xa)) | ((!!((8)&0xc))<<1))),
 T_BOOL8 = (((2) << 2) | ((!!((1)&0xa)) | ((!!((1)&0xc))<<1))),
 T_U64 = (((3) << 2) | ((!!((8)&0xa)) | ((!!((8)&0xc))<<1))),
 T_U32 = (((3) << 2) | ((!!((4)&0xa)) | ((!!((4)&0xc))<<1))),
 T_U16 = (((3) << 2) | ((!!((2)&0xa)) | ((!!((2)&0xc))<<1))),
 T_U8 = (((3) << 2) | ((!!((1)&0xa)) | ((!!((1)&0xc))<<1))),
 T_ID = T_U64,
 T_POSITION = T_U64 | ((!!((sizeof(gridpos))&0xa)) | ((!!((sizeof(gridpos))&0xc))<<1)),
 T_USERDATA = T_U64 | ((!!((sizeof(void *))&0xa)) | ((!!((sizeof(void *))&0xc))<<1))
} type;
typedef union pvalue {
 double f64; uint64_t u64; gridpos z; void *u;
} pvalue;
typedef union tvalue {
 double f64; uint64_t u64; gridpos z; void *u;
 float f32;
 uint8_t u8;
 uint16_t u16;
 uint32_t u32;
} tvalue;


pvalue vpromote(tvalue v, type t);
tvalue vdemote(pvalue v, type t);
tvalue vbroadcast(tvalue v, type t);
unsigned vbunpack(uint64_t b);
uint64_t vbpack(unsigned b);
double vexportd(pvalue v, type t);
pvalue vimportd(double d, type t);
       
typedef struct sim sim;
typedef uint64_t sim_branchid;
enum {
 SIM_MUTABLE = 0x1,
 SIM_FRAME = 0x2
};
sim *sim_create();
void sim_destroy(sim *sim);
void *sim_static_alloc(sim *sim, size_t sz, size_t align);
void *sim_vstack_alloc(sim *sim, size_t sz, size_t align);
void *sim_frame_alloc(sim *sim, size_t sz, size_t align);
void *sim_alloc(sim *sim, size_t sz, size_t align, int lifetime);
int sim_is_frame_owned(sim *sim, void *p);
unsigned sim_frame_id(sim *sim);
void sim_savepoint(sim *sim);
void sim_restore(sim *sim);
void sim_enter(sim *sim);
void sim_exit(sim *sim);
void sim_branch(sim *sim, size_t n, sim_branchid *branches);
bool sim_next_branch(sim *sim);
       
       
struct vec_band {
 unsigned stride;
 unsigned tag;
 void *data;
};
struct vec {
 unsigned n_alloc;
 unsigned n_used;
 unsigned n_bands;
 struct vec_band bands[];
};
union vec_tpl {
 void *p;
 uint64_t u64;
};
struct vec_ref {
 struct vec *vec;
 unsigned idx;
};
struct vec_slice {
 struct vec *vec;
 unsigned from;
 unsigned to;
};
void vec_init(struct vec *v, unsigned n_bands);
void vec_init_range(struct vec *v, unsigned from, unsigned to, union vec_tpl *tpl);
unsigned vec_copy_skip(struct vec *v, void **dst, unsigned n, unsigned *skip);
unsigned vec_copy_skip_s(struct vec *v, void **dst, unsigned n, unsigned *skip);
unsigned vec_header_size(unsigned n_bands);
struct svgrid {
 struct grid grid;
 unsigned z_band;
 struct vec tpl;
};
enum {
 POSITION_RESOLUTION = 31,
 POSITION_ORDER = ((POSITION_RESOLUTION)<<1)
};
enum {
 SIM_DATA_MUTABLE = 0x4
};
void *sim_create_data(sim *sim, size_t size, size_t align, int lifetime);
struct grid *sim_create_grid(sim *sim, size_t order, size_t size, int lifetime);
struct svgrid *sim_create_svgrid(sim *sim, size_t order, unsigned z_band, struct vec *tpl);
struct vec *sim_create_vec(sim *sim, struct vec *tpl, int lifetime);
unsigned frame_alloc_vec(sim *sim, struct vec *v, unsigned n);
void frame_delete_vec(sim *sim, struct vec *v, unsigned n, unsigned *del);
void frame_clear_vec(sim *sim, struct vec *v);
void frame_swap_band(sim *sim, struct vec *v, unsigned band, void *data);
void frame_swap_grid(sim *sim, struct grid *g, void *data);
void *frame_create_band(sim *sim, struct vec *v, unsigned band);
void *frame_create_grid_data(sim *sim, struct grid *g);
struct vec *frame_lazy_svgrid_vec(sim *sim, struct svgrid *g, gridpos z);
unsigned frame_alloc_svgrid(sim *sim, struct vec_slice *ret, struct svgrid *g, unsigned n,
  gridpos *z);
unsigned frame_alloc_svgrid_s(sim *sim, struct vec_slice *ret, struct svgrid *g, unsigned n,
  gridpos *z);
       
       
typedef struct arena arena;
typedef struct arena_ptr {
 void *chunk;
 void *ptr;
} arena_ptr;
arena *arena_create(size_t size);
void arena_destroy(arena *arena);
void arena_reset(arena *arena);
void *arena_alloc(arena *arena, size_t size, size_t align);
void *arena_malloc(arena *arena, size_t size);
char *arena_salloc(arena *arena, size_t size);
void arena_save(arena *arena, arena_ptr *p);
void arena_restore(arena *arena, arena_ptr *p);
int arena_contains(arena *arena, void *p);
char *arena_vasprintf(arena *arena, const char *fmt, va_list arg);
char *arena_asprintf(arena *arena, const char *fmt, ...);
char *arena_strcpy(arena *arena, const char *src);
enum fhk_ctype {
 FHK_RIVAL,
 FHK_BITSET
};
struct fhk_rival {
 double min;
 double max;
};
struct fhk_cst {
 enum fhk_ctype type;
 union {
  struct fhk_rival rival;
  uint64_t setmask;
 };
};
struct fhk_space {
 struct fhk_cst cst;
};
enum {
 FHK_COST_OUT = 0,
 FHK_COST_IN = 1
};
struct fhk_check {
 struct fhk_var *var;
 struct fhk_cst cst;
 double costs[2];
};
struct fhk_model {
 unsigned idx : 16;
 unsigned n_check : 8;
 unsigned n_param : 8;
 unsigned n_return : 8;
 unsigned may_fail : 1;
 struct fhk_check *checks;
 struct fhk_var **params;
 struct fhk_var **returns;
 pvalue *rvals;
 double k, c;
 double min_cost, max_cost;
 void *udata;
};
struct fhk_var {
 unsigned idx : 16;
 unsigned n_fwd : 16;
 unsigned n_mod : 8;
 unsigned hptr : 8;
 struct fhk_model **models;
 struct fhk_model **fwd_models;
 struct fhk_model *model;
 pvalue value;
 double min_cost, max_cost;
 void *udata;
};
typedef union fhk_mbmap { uint8_t u8; struct { unsigned blacklisted : 1; unsigned has_bound : 1; unsigned chain_selected : 1; unsigned has_return : 1; unsigned mark : 1; } __attribute__((packed));  } fhk_mbmap;
typedef union fhk_vbmap { uint8_t u8; struct { unsigned given : 1; unsigned mark : 1; unsigned chain_selected : 1; unsigned has_value : 1; unsigned has_bound : 1; unsigned stable : 1; unsigned target : 1; } __attribute__((packed));  } fhk_vbmap;
enum {
 FHK_NOT_RESOLVED = -1,
 FHK_OK = 0,
 FHK_RESOLVE_FAILED = 1,
 FHK_MODEL_FAILED = 2,
 FHK_SOLVER_FAILED = 3
};
struct fhk_einfo {
 int err;
 struct fhk_model *model;
 struct fhk_var *var;
};
typedef struct fhk_graph fhk_graph;
typedef int (*fhk_model_exec)(fhk_graph *G, void *udata, pvalue *ret, pvalue *args);
typedef int (*fhk_var_resolve)(fhk_graph *G, void *udata, pvalue *value);
typedef void (*fhk_chain_solved)(fhk_graph *G, void *udata, pvalue value);
typedef const char *(*fhk_desc)(void *udata);
struct fhk_graph {
 fhk_model_exec exec_model;
 fhk_var_resolve resolve_var;
 fhk_chain_solved chain_solved;
 fhk_desc debug_desc_var;
 fhk_desc debug_desc_model;
 size_t n_var;
 struct fhk_var *vars;
 fhk_vbmap *v_bitmaps;
 size_t n_mod;
 struct fhk_model *models;
 fhk_mbmap *m_bitmaps;
 unsigned dirty;
 struct fhk_einfo last_error;
 void *udata;
};
struct fhk_solver {
 struct fhk_graph *G;
 bm8 *reset_v;
 bm8 *reset_m;
 unsigned nv;
 struct fhk_var **xs;
 pvalue **res;
};
void fhk_reset(struct fhk_graph *G, fhk_vbmap vmask, fhk_mbmap mmask);
void fhk_reset_mask(struct fhk_graph *G, bm8 *vmask, bm8 *mmask);
void fhk_supp(bm8 *vmask, bm8 *mmask, struct fhk_var *y);
void fhk_inv_supp(struct fhk_graph *G, bm8 *vmask, bm8 *mmask);
int fhk_solve(struct fhk_graph *G, size_t nv, struct fhk_var **ys);
struct fhk_graph *fhk_alloc_graph(arena *arena, size_t n_var, size_t n_mod);
void fhk_copy_checks(arena *arena, struct fhk_model *m, size_t n_check, struct fhk_check *checks);
void fhk_copy_params(arena *arena, struct fhk_model *m, size_t n_param, struct fhk_var **params);
void fhk_copy_returns(arena *arena, struct fhk_model *m, size_t n_ret, struct fhk_var **returns);
void fhk_compute_links(arena *arena, struct fhk_graph *G);
struct fhk_var *fhk_get_var(struct fhk_graph *G, unsigned idx);
struct fhk_model *fhk_get_model(struct fhk_graph *G, unsigned idx);
void fhk_solver_init(struct fhk_solver *s, struct fhk_graph *G, unsigned nv);
void fhk_solver_destroy(struct fhk_solver *s);
void fhk_solver_bind(struct fhk_solver *s, unsigned vidx, pvalue *res);
int fhk_solver_step(struct fhk_solver *s, unsigned idx);
       
       
enum {
 MODEL_CALL_OK = 0,
 MODEL_CALL_RUNTIME_ERROR = 1,
 MODEL_CALL_INVALID_RETURN = 2
};
enum {
 MODEL_CALIBRATED = 0x1,
 MODEL_INTERPOLATE = 0x2
};
typedef struct model model;
typedef int (*model_call_f)(model *, pvalue *ret, pvalue *argv);
typedef void (*model_calibrate_f)(model *);
typedef void (*model_destroy_f)(model *);
struct model_func {
 model_call_f call;
 model_calibrate_f calibrate;
 model_destroy_f destroy;
};
struct model {
 const struct model_func *func;
 unsigned flags;
 unsigned n_arg;
 unsigned n_ret;
 unsigned n_coef;
 type *atypes;
 type *rtypes;
 double *coefs;
};
const char *model_error();
enum {
 GMAP_BIND_OBJECT,
 GMAP_BIND_Z,
 GMAP_BIND_GLOBAL
};
typedef struct gmap_support {
 bool (*is_visible)(tvalue to, unsigned reason, tvalue parm);
 bool (*is_constant)(tvalue to, unsigned reason, tvalue parm);
} gmap_support;
typedef tvalue (*gmap_resolve)(void *);
struct gmap_any {
 const gmap_support *supp; gmap_resolve resolve; tvalue udata; const char *name; unsigned target_type : 16;
};
struct gv_vec {
 const gmap_support *supp; gmap_resolve resolve; tvalue udata; const char *name; unsigned target_type : 16;
 unsigned target_offset : 16;
 unsigned target_band : 16;
 struct vec_ref *bind;
};
struct gv_grid {
 const gmap_support *supp; gmap_resolve resolve; tvalue udata; const char *name; unsigned target_type : 16;
 unsigned target_offset : 16;
 struct grid *grid;
 gridpos *bind;
};
struct gv_data {
 const gmap_support *supp; gmap_resolve resolve; tvalue udata; const char *name; unsigned target_type : 16;
 void *ref;
};
struct gmap_model {
 const char *name;
 struct model *mod;
};
void gmap_hook(struct fhk_graph *G);
void gmap_bind(struct fhk_graph *G, unsigned idx, struct gmap_any *g);
void gmap_unbind(struct fhk_graph *G, unsigned idx);
void gmap_bind_model(struct fhk_graph *G, unsigned idx, struct gmap_model *m);
void gmap_unbind_model(struct fhk_graph *G, unsigned idx);
void gmap_supp_obj_var(struct gmap_any *v, uint64_t objid);
void gmap_supp_grid_env(struct gmap_any *v, uint64_t order);
void gmap_supp_global(struct gmap_any *v);
tvalue gmap_res_vec(void *v);
tvalue gmap_res_grid(void *v);
tvalue gmap_res_data(void *v);
void gmap_mark_visible(struct fhk_graph *G, bm8 *vmask, unsigned reason, tvalue parm);
void gmap_mark_nonconstant(struct fhk_graph *G, bm8 *vmask, unsigned reason, tvalue parm);
void gmap_make_reset_masks(struct fhk_graph *G, bm8 *vmask, bm8 *mmask);
void gmap_init(struct fhk_graph *G, bm8 *init_v);
       
typedef uint32_t gs_res;
enum {
 GS_RETURN = 1 << 31,
 GS_INTERRUPT_VIRT = 1 << 30,
 GS_ARG_MASK = (1 << 16) - 1
};
struct gs_virt {
 const gmap_support *supp; gmap_resolve resolve; tvalue udata; const char *name; unsigned target_type : 16;
 int32_t handle;
};
typedef struct gs_ctx gs_ctx;
gs_ctx *gs_create_ctx();
void gs_destroy_ctx(gs_ctx *ctx);
void gs_enter(gs_ctx *ctx);
void gs_interrupt(gs_res ir);
gs_res gs_resume(tvalue iv);
tvalue gs_res_virt(void *v);
gs_res gs_solve_step(struct fhk_solver *solver, unsigned idx);
gs_res gs_solve_vec(struct vec_ref *v_bind, struct fhk_solver *solver, struct vec *vec);
gs_res gs_solve_vec_z(struct vec_ref *v_bind, gridpos *z_bind, int z_band, struct fhk_solver *solver,
  struct vec *vec);
       
typedef double vreal;
typedef uint64_t vmask;
void vsetc(vreal *d, vreal c, size_t n);
void vsaddc(vreal *d, vreal a, vreal *x, vreal b, size_t n);
void vaddc(vreal *d, vreal *x, vreal c, size_t n);
void vaddsv(vreal *d, vreal *x, vreal a, const vreal *restrict y, size_t n);
void vaddv(vreal *d, vreal *x, const vreal *restrict y, size_t n);
void vscale(vreal *d, vreal *x, vreal a, size_t n);
void vmulv(vreal *d, vreal *x, const vreal *restrict y, size_t n);
void vrefl(vreal *d, vreal a, vreal *x, const vreal *restrict y, size_t n);
void varead(vreal *d, vreal *x, size_t n);
void vsorti(unsigned *idx, vreal *x, size_t n);
vreal vsum(vreal *x, size_t n);
vreal vsumm(vreal *x, vmask *m, vmask mask, size_t n);
void vpsumi(vreal *d, const vreal *restrict x, unsigned *idx, size_t n);
void vpsumim(vreal *d, const vreal *restrict x, unsigned *idx, vmask *m, vmask mask, size_t n);
void vmexpand8(vmask *m, uint8_t *mask, size_t n);
void vmexpand16(vmask *m, uint16_t *mask, size_t n);
void vmexpand32(vmask *m, uint32_t *mask, size_t n);
       
       
void *maux_get_file_data(const char *file);
void maux_set_file_data(const char *file, void *udata);
void maux_initmodel(
  struct model *m, const struct model_func *func,
  unsigned n_arg, type *atypes,
  unsigned n_ret, type *rtypes,
  unsigned n_coef, unsigned flags
);
void maux_destroymodel(struct model *m);
void maux_exportd(struct model *m, pvalue *argv);
void maux_importd(struct model *m, pvalue *retv);
void maux_errf(const char *fmt, ...);
enum mod_R_calib_mode {
 MOD_R_EXPAND,
 MOD_R_PASS_VECTOR
};
struct mod_R_def {
 unsigned n_arg; unsigned n_ret; type *atypes; type *rtypes; unsigned flags;
 const char *fname;
 const char *func;
 unsigned n_coef;
 enum mod_R_calib_mode mode;
};
model *mod_R_create(struct mod_R_def *def);
       
struct mod_SimoC_def {
 unsigned n_arg; unsigned n_ret; type *atypes; type *rtypes; unsigned flags;
 const char *libname;
 const char *func;
};
model *mod_SimoC_create(struct mod_SimoC_def *def);
       
enum mod_Lua_calib_mode {
 MOD_LUA_EXPAND,
 MOD_LUA_PASS_TABLE
};
struct mod_Lua_def {
 unsigned n_arg; unsigned n_ret; type *atypes; type *rtypes; unsigned flags;
 const char *module;
 const char *func;
 unsigned n_coef;
 enum mod_Lua_calib_mode mode;
};
model *mod_Lua_create(struct mod_Lua_def *def);
static const int HAVE_SOLVER_INTERRUPTS = 1;
]]
