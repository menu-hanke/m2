-- Autogenerated file - don't touch
local ffi = require 'ffi'
ffi.cdef [[
       
       
       
typedef enum type {
 T_F32 = 0,
 T_F64 = 1,
 T_I8 = 2,
 T_I16 = 3,
 T_I32 = 4,
 T_I64 = 5,
 T_B8 = 6,
 T_B16 = 7,
 T_B32 = 8,
 T_B64 = 9
} type;
typedef enum ptype {
 PT_REAL = 1,
 PT_INT = 2,
 PT_BIT = 3
} ptype;
typedef union pvalue {
 double r;
 int64_t i;
 uint64_t b;
} pvalue;

typedef unsigned lexid;
struct type_def {
 const char *name;
 size_t size;
};
struct bitenum_def {
 const char *name;
 uint64_t bit_mask;
 const char **value_names;
};
struct var_def {
 lexid id;
 const char *name;
 type type;
 union {
  struct bitenum_def *bitenum_def;
 };
};
struct obj_ref {
 struct obj_def *ref;
 int back_idx;
};
struct obj_def {
 lexid id;
 const char *name;
 struct { size_t n; struct var_def * *data; } vars;
 struct { size_t n; struct obj_ref *data; } uprefs;
 struct { size_t n; struct obj_ref *data; } downrefs;
};
struct lex {
 struct { size_t n; struct type_def *data; } types;
 struct { size_t n; struct var_def *data; } vars;
 struct { size_t n; struct obj_def *data; } objs;
};
struct lex *lex_create(size_t n_types, size_t n_vars, size_t n_objs);
void lex_destroy(struct lex *lex);
void lex_set_vars(struct lex *lex, lexid objid, size_t n, lexid *varids);
void lex_set_uprefs(struct lex *lex, lexid objid, size_t n, lexid *objids);
void lex_compute_refs(struct lex *lex);
size_t lex_get_roots(struct lex *lex, struct obj_def **objs);
const struct type_def *get_typedef(type t);
size_t get_enum_size(uint64_t bit_mask);
type get_enum_type(struct bitenum_def *ed);
int unpackenum(uint64_t b);
uint64_t packenum(int b);
ptype tpromote(type t);
pvalue promote(void *x, type t);
void demote(void *x, type t, pvalue p);
       
typedef struct sim sim;
typedef struct sim_vec sim_vec;
enum {
 SIM_ITER_END = 0,
 SIM_ITER_NEXT = -1
};
enum {
 SIM_OK = 0,
 SIM_EOOM = 1,
 SIM_EDEPTH_LIMIT = 2,
 SIM_EINVALID_FRAME = 3
};
typedef struct sim_objref {
 sim_vec *vec;
 size_t idx;
} sim_objref;
typedef struct sim_slice {
 sim_vec *vec;
 size_t from;
 size_t to;
} sim_slice;
typedef struct sim_iter {
 sim_objref ref;
 int upref;
} sim_iter;
sim *sim_create(struct lex *lex);
void sim_destroy(sim *sim);
void sim_allocv(sim *sim, sim_slice *pos, lexid objid, sim_objref *uprefs, size_t n);
int sim_first(sim *sim, sim_iter *it, lexid objid, sim_objref *upref, int uprefidx);
int sim_next(sim_iter *it);
sim_vec *sim_first_rv(sim *sim, lexid objid);
sim_vec *sim_next_rv(sim_vec *prev);
void sim_used(sim_vec *vec, sim_slice *slice);
void *sim_varp(sim *sim, sim_objref *ref, lexid objid, lexid varid);
void *sim_varp_base(sim_vec *vec, lexid varid);
pvalue sim_read1p(sim *sim, sim_objref *ref, lexid objid, lexid varid);
void sim_write1p(sim *sim, sim_objref *ref, lexid objid, lexid varid, pvalue value);
sim_objref *sim_get_upref(sim_vec *vec, int uprefidx);
int sim_enter(sim *sim);
void sim_rollback(sim *sim);
int sim_exit(sim *sim);
       
       
typedef uint8_t bm8 __attribute__((aligned(16)));
bm8 *bm_alloc(size_t n);
void bm_free(bm8 *bm);
void bm_zero(bm8 *bm, size_t n);
void bm_copy(bm8 *restrict a, const bm8 *restrict b, size_t n);
void bm_and(bm8 *bm, size_t n, uint8_t mask);
void bm_or(bm8 *bm, size_t n, uint8_t mask);
void bm_xor(bm8 *bm, size_t n, uint8_t mask);
void bm_and2(bm8 *restrict a, const bm8 *restrict b, size_t n);
void bm_or2(bm8 *restrict a, const bm8 *restrict b, size_t n);
void bm_xor2(bm8 *restrict a, const bm8 *restrict b, size_t n);
void bm_not(bm8 *bm, size_t n);
enum fhk_ctype {
 FHK_RIVAL,
 FHK_IIVAL,
 FHK_BITSET
};
struct fhk_rival {
 double min;
 double max;
};
struct fhk_iival {
 int64_t min;
 int64_t max;
};
struct fhk_cst {
 enum fhk_ctype type;
 union {
  struct fhk_rival rival;
  struct fhk_iival iival;
  uint64_t setmask;
 };
};
struct fhk_space {
 struct fhk_cst cst;
};
enum {
 FHK_COST_OUT = 0,
 FHK_COST_IN = 1
};
struct fhk_check {
 struct fhk_var *var;
 struct fhk_cst cst;
 double costs[2];
};
struct fhk_mmark {
 double min_cost, max_cost;
};
struct fhk_vmark {
 union {
  struct {
   pvalue value;
   struct fhk_model *model;
   double min_cost, max_cost;
  };
  struct {
   struct fhk_space space;
   unsigned limit_space : 1;
   unsigned given : 1;
  };
 };
};
struct fhk_model {
 int idx;
 double k, c;
 size_t n_check;
 struct fhk_check *checks;
 size_t n_param;
 struct fhk_var **params;
 unsigned may_fail : 1;
 struct fhk_mmark mark;
 void *udata;
};
struct fhk_var {
 int idx;
 size_t n_mod;
 struct fhk_model **models;
 unsigned is_virtual : 1;
 struct fhk_vmark mark;
 void *udata;
};
typedef union fhk_mbmap { uint8_t u8; struct { unsigned skip : 1; unsigned has_bound : 1; unsigned chain_selected : 1; } __attribute__((packed));  } fhk_mbmap;
typedef union fhk_vbmap { uint8_t u8; struct { unsigned given : 1; unsigned solve : 1; unsigned solving : 1; unsigned chain_selected : 1; unsigned has_value : 1; unsigned has_bound : 1; } __attribute__((packed));  } fhk_vbmap;
enum {
 FHK_RESET_GIVEN = 0x1,
 FHK_RESET_SOLVE = 0x2,
 FHK_RESET_ALL = FHK_RESET_GIVEN | FHK_RESET_SOLVE
};
enum {
 FHK_OK = 0,
 FHK_MODEL_FAILED = 1,
 FHK_RESOLVE_FAILED = 2,
 FHK_CYCLE = 3,
 FHK_REQUIRED_UNSOLVABLE = 4
};
struct fhk_einfo {
 int err;
 struct fhk_model *model;
 struct fhk_var *var;
};
typedef struct fhk_graph fhk_graph;
typedef int (*fhk_model_exec)(fhk_graph *G, void *udata, pvalue *ret, pvalue *args);
typedef int (*fhk_var_resolve)(fhk_graph *G, void *udata, pvalue *value);
typedef const char *(*fhk_desc)(void *udata);
struct fhk_graph {
 fhk_model_exec model_exec;
 fhk_var_resolve resolve_virtual;
 fhk_desc debug_desc_var;
 fhk_desc debug_desc_model;
 size_t n_var;
 size_t n_mod;
 fhk_vbmap *v_bitmaps;
 fhk_mbmap *m_bitmaps;
 struct fhk_einfo last_error;
 void *udata;
};
void fhk_graph_init(struct fhk_graph *G);
void fhk_graph_destroy(struct fhk_graph *G);
void fhk_set_given(struct fhk_graph *G, struct fhk_var *x);
void fhk_set_solve(struct fhk_graph *G, struct fhk_var *y);
void fhk_reset(struct fhk_graph *G, int what);
void fhk_sup(bm8 *vmask, bm8 *mmask, struct fhk_var *y);
void fhk_inv_sup(struct fhk_graph *G, bm8 *vmask, bm8 *mmask, struct fhk_var *y);
int fhk_solve(struct fhk_graph *G, struct fhk_var *y);
       
typedef int (*ex_exec_f)(void *, pvalue *ret, pvalue *argv);
typedef void (*ex_destroy_f)(void *);
struct ex_impl {
 ex_exec_f exec;
 ex_destroy_f destroy;
};
typedef struct ex_func {
 const struct ex_impl *impl;
} ex_func;
ex_func *ex_R_create(const char *fname, const char *func, int narg, ptype *argt, int nret,
  ptype *rett);
       
typedef struct arena arena;
arena *arena_create(size_t size);
void arena_destroy(arena *arena);
void arena_reset(arena *arena);
void *arena_alloc(arena *arena, size_t size, size_t align);
void *arena_malloc(arena *arena, size_t size);
       
typedef struct ufhk ufhk;
typedef struct uset uset;
ufhk *ufhk_create(struct lex *lex);
void ufhk_destroy(ufhk *u);
void ufhk_set_var(ufhk *u, lexid varid, struct fhk_var *x);
void ufhk_set_model(ufhk *u, const char *name, ex_func *f, struct fhk_model *m);
void ufhk_set_graph(ufhk *u, struct fhk_graph *G);
int ufhk_update(ufhk *u, uset *s, sim *sim);
int ufhk_update_slice(ufhk *u, uset *s, sim_slice *slice);
uset *uset_create(ufhk *u, lexid objid, size_t nvars, lexid *vars);
void uset_destroy(uset *s);
]]
